데이터베이스 면접 질문
# 데이터베이스 기본 내용
Q. Database와 DBMS란?

A. Database는 사용자가 필요한 정보를 얻기 위해 논리적으로 연관된 데이터를 모아 구조적으로 통합해 놓은 것입니다.

DBMS는 Database Management System의 약자로 사용자와 데이터베이스를 연결시켜주는 소프트웨어입니다. 즉 DB를 관리하기 위한 시스템입니다. (대표적으로 구성, 조작, 제어 등의 기능을 가집니다.)

Q. SQL이란? SQL의 종류는?

A. SQL(Structured Query Language)는 구조적 질의 언어로 해당 질의 언어를 통해 데이터베이스를 제어하고 관리할 수 있다.

SQL 종류로는 DDL(Data Definition Language), DML(Data ManipulationLanguage), DCL(Data Control Language)이 있다. DDL은 데이터베이스 구조를 정의, 수정, 삭제하는 언어이며 create, alter, drop 등이 있다. DML은 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어로 select, delete, update, insert가 있다. DCL은 데이터에 대해 무결성을 유지, 병행 수행 제어, 보호와 관리를 위한 언어로 commit, rollback, grant, revoke가 있다.

Q. DB에서 Index를 사용하는 이유는?

A. 인덱스(Index)는 데이터를 논리적으로 정렬하여 검색과 정렬 작업의 속도를 높이기 위해 사용된다. 예를 들면, 책에서 가장 빨리 내용을 찾는 방법은 책의 뒤편의 색인을 보는 것과 같다.

기본키에 대해서는 항상 DBMS가 내부적으로 정렬된 목록을 관리하기에 특정 행을 가져올 때 빠르게 처리된다. 하지만, 다른 열의 내용을 검색하거나 정렬시에는 하나하나 대조를 해보기 때문에 시간이 오래걸린다. (이를 인덱스로 정의해두면 검색속도가 향상된다.)

단점: 인덱스를 사용하면 데이터를 가져오는 작업의 성능은 향상시킬 수 있지만 데이터 삽입, 변경 등이 일어날 때 매번 인덱스가 변경되기 때문에 성능이 떨어질 수 있다.

사용대상 : 데이터 필터링과 정렬에 사용되므로, 데이터를 특정한 순서로 자주 정렬한다면 인덱스를 사용하기에 적합

# 무결성
Q. 무결성이란?

A. 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 데이터의 무결성을 유지하기 위해 DBMS에서는 크게 3가지 종류로 구분한다. (개체, 참조, 도메인 무결성 가장 중요)

- 개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않는다. (PK는 NULL이 되면 안된다.)
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지한다. (FK의 값은 NULL이거나 참조하고 있는 컬럼에 있는 값이여야 한다.)
- 도메인 무결성 : 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력됬는지를 체크하는 것이다. (예를 들면 성과 같은 컬럼의 값은 남/여 만 가능)
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성값은 모두 고유한 값을 가진다. 같으면 안된는 것
- NULL 무결성 : 특정 속성값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성값은 NULL이 될 수 없다는 제약조건
- 키 무결성 : 한 릴레이션에는 최소한 하나의 키가 존재해야하는 제약조건

Q. 무결성을 유지하려고 하는 이유?

A. 무결성이 유지가 되어야 DB에 저장된 데이터 값과 거기에 해당하는 현실 세계의 실제값이 일치하는지 신뢰할 수 있기 때문이다.

# 트랜잭션 (동시성 제어, 데이터베이스 장애 및 회복)
Q. 트랜잭션이 뭔가요?

A. 하나의 논리적 기능을 수행하기 위한 작업의 단위로, DB의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.

트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야한다.

Q. 트랜잭션의 성질을 말씀해보세요.

A. ACID라 불리는 총 네가지 성질을 가지고있습니다.

Atomicity는 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.(원자성)

Consistency는 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.(일관성)
(예를 들면 A에서 B로 돈 이체를 할때 A와 B 계좌의 돈의 총합은 같아야한다.)

Isolation은 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.(독립성)
(따라서 트랜잭션이 동시 접근하는 데이터에대한 제어가 필요하다.)

Durablility는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.(영속성)
(트랜잭션이 정상적으로 완료(commit)된 경우에는 하드디스크(데이터베이스)에 확실히 기록해야하며, 부분완료된 경우 작업을 취소해야합니다.)

Q. 트랜잭션을 병행으로 처리(동시성 제어)하려고 할 때 발생할 수 있는 문제를 설명해보시오.

A.

갱신 내용 손실 : 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우

현황 파악 오류 : 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우

모순성 : 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제

연쇄 복귀 : 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

Q. 트랜잭션을 병행으로 처리할 때 위와 같은 문제를 방지하기 위한 방법을 설명하시오.

A. 로킹 제어 기법을 사용한다.

어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock시키고 트랜잭션이 완료될때 해당부분을 Unlock시키는 방법이다. 종류는 크게 두가지가 있는데 공유 로킹은 Lock한 부분을 읽기는 가능하지만 쓰기는 불가능한 것이고 배타 로킹은 읽기,쓰기 둘다 불가능하게 한 것이다.

Q. 그렇다면 이 로킹 단위를 크게했을 때와 작게 했을 때의 차이점을 설명하시오.

A. 로킹 단위가 크면 그만큼 관리가 쉽지만 병행성이 떨어진다. 로킹단위가 작으면 관리가 어렵고 오버헤드가 증가하지만, 병행성이 올라간다.

Q. 로킹 제어가 일으킬 수 있는 문제점은 무엇인가?

A. 로킹단위에 따라 다르겠지만 트랜잭션의 직렬화 가능성이 높아진다.(병행처리하나마나 할 수도있다.) 또 데드락이 발생할 수 있다.

Q. 데드락에 대해서 설명해보세요.

T1 : write(A) read(B)

T2 : read(B) read(A)

위와 같은 트랜잭션이 있다고 하면 T1은 A를 로킹해두고 B의 로킹해제를 기다려야하고 T2는 B를 로킹해두고 A를 기다려야한다. 이 때 두 트랜잭션이 무한정 대기해야하는 상황이 발생하는데 이것을 데드락이라고 한다. (해결방법 : 이 경우 T1, T2중 하나를 ROLLBACK하고 나머지 하나를 완료시킨 후 ROLLBACK한 트랜잭션을 다시 실행시킨다.)

Q. 그럼 데드락을 안 생기게 하는 방법을 설명해보시오.

A.

서비스 별로 해결하는 방법이 매우 다른데 일반적으로는 데드락 탐지나 회피를 적용시키면 된다.

탐지인 경우 알고리즘을 통해 매번 데드락인지 아닌지 검사를 해야하므로 코스트가 크다.

회피인 경우 시분할 처리를하여 T1이 끝나면 T2가 실행시키게도 하면된다.

Facebook 처럼 write 보다 read가 월등히 많은 경우 Read용 DB를 slave로 두고 로드를 모두 몰아주고 write를 Master로 보내고 DB를 동기화 할 수도 있다.

또 다른 해결기법으론 로킹 제어기법이 아닌 타임스탬프 기법을 사용한다. 트랜잭션의 식별자로 타임스탬프를 지정하며 순서를 미리 선택한다. 트랜잭션이 대기하지 않고 바로 실행은 하나 높은 확률로 ROLLBACK이 일어나며 연쇄 복귀를 초래할 수 있다.

Q. COMMIT과 ROLLBACK에 대해 설명해보세요.

A. DML을 수행하고 난 뒤 COMMIT은 해당 트랜잭션으로 반영된 DB 변경사항을 저장 하는 것이고 ROLLBACK은 해당 트랜잭션으로 반영된 DB 변경사항을 취소 하는 것이다.

Q. 데이터베이스 장애의 유형

A. 

트랜잭션 장애: 트랜잭션의 실행 시 논리적인 오류로 발생할 수 있는 에러 상황

시스템 장애: H/W 시스템 자체에서 발생할 수 있는 에러 상황

미디어 장애: 디스크 자체의 손상으로 발생할 수 있는 에러 상황

Q. 데이터베이스 회복 기법에 대해 설명하시오.

A.

로그기반 회복기법

지연 갱신 회복 기법

write 연산 지연, 로그에 DB변경 내역 저장

트랜잭션 완료시 로그를 보고 write 연산 수행

트랜잭션 완료시 장애 발생 : REDO만 실행

트랜잭션 미완료시 장애 발생 : 로그 무시

즉시 갱신 회복 기법

즉시 DB 변경, 로그에 기록

장애 발생 시 로그에 기반하여 UNDO 실행

체크포인트 회복기법

체크 포인트를 지정하여 장애발생시 체크포인트까지 UNDO 실행 후 다시 REDO 실행

그림자 페이징 회복 기법

하드디스크에 그림자 페이지를 만들고 저장해두고 장애발생시 하드디스크에 있는 페이지로 주메모리 페이지 변경

장애 미발생시 그림자 페이지 테이블은 삭제

 

* 트랜잭션 설명 및 예제가 가장 잘 나와있다고 생각되는 사이트

https://mangkyu.tistory.com/30?category=761304

# 정규화
Q. DB Normalization(정규화)란?

A. 데이터베이스 정규화란 데이터의 중복을 줄이고 무결성을 향상 시키는 등 여러 목적을 달성하기 위해 관계형 데이터베이스를 정규화된 형태로 재디자인하는 것을 말한다.

Q. DB Normalization(정규화)의 목적은?

A.

불필요한 데이터를 제거, 데이터의 중복을 최소화 하기 위해서

데이터베이스 구조 확장 시 재디자인을 최소화

다양한 관점에서의 query를 지원하기 위해서

무결성 제약조건의 시행을 간단하게 하기 위해서

각종 이상현상을 방지하기 위해서, 테이블의 구성을 논리적이고 직관적으로 한다.

Q. 이상현상 이란?

A.
좋은 관계형 데이터베이스를 설계하는 목적 중 하나가 정보의 이상 현상(Anomaly) 이 생기지 않도록 고려해 설계하는 것이다.
이상 현상은 갱신 이상(Modification Anomaly), 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly) 으로 구성된다.
각각을 간략하게 설명하면 다음과 같다.

갱신 이상(Modification Anomaly): 반복된 데이터 중에 일부를 갱신 할 시 데이터의 불일치가 발생한다.

삽입 이상(Insertion Anomaly): 불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능하다.

삭제 이상(Deletion Anomaly): 필요한 정보를 함께 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능하다.

Q. 정규화 과정?

A. 정규화는 1정규화 ~ 6정규화 까지 있지만, 실무에서는 대체로 1~3 정규화까지의 과정을 거친다.

제 1정규화 : 각 컬럼들은 값이 원자값을 가지게 바꾼다.

제 2정규화 : 테이블의 모든 컬럼에서 부분 함수적 종속을 제거하는 것

제 3정규화 : 기본키를 제외한 속성들 간의 이행적 함수 종속을 없애는 것

제 1정규화(First Normal Form, 1NF)

테이블(Relation)이 제 1정규형을 만족했다는 것은 아래 세 가지 조건를 만족했다는 것을 의미한다.

어떤 Relation에 속한 모든 Domain이 원자값(atomic value)만으로 되어 있다.

모든 attribute에 반복되는 그룹(repeating group)이 나타나지 않는다.

기본 키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다.

제 2정규화(Second Normal Form, 2NF)

제 2정규화를 수행 했을 경우 테이블의 모든 컬럼이 완전 함수적 종속을 만족한다.(부분 함수적 종속을 모두 제거되었다.) 이를 이해하기 위해서는 부분 함수적 종속과 완전 함수적 종속이라는 용어를 알아야 한다.

함수적 종속: X의 값에 따라 Y값이 결정될 때 X -> Y로 표현하는데, 이를 Y는 X에 대해 함수적 종속 이라고 한다. 예를 들어 학번을 알면 이름을 알 수 있는데, 이 경우엔 학번이 X가 되고 이름이 Y가 된다. X를 결정자이라고 하고, Y는 종속자라고 한다. 다른 말로 X가 바뀌었을 경우 Y가 바뀌어야만 한다는 것을 의미한다.

함수적 종속에서 X의 값이 여러 요소일 경우, 즉, {X1, X2} -> Y일 경우, X1와 X2가 Y의 값을 결정할 때 이를 완전 함수적 종속 이라고 하고, X1, X2 중 하나만 Y의 값을 결정할 때 이를 부분 함수적 종속 이라고 한다.

제 3정규화(Third Normal Form, 3NF)

테이블(Relation)이 제 3정규형을 만족한다는 것은 아래 두 가지 조건을 만족하는 것을 의미한다.

Relation이 제 2정규화 되었다.(The relation is in second normal form)

기본 키(primary key)가 아닌 속성(Attribute)들은 기본 키에만 의존해야 한다.

Q. 역정규화를 하는 이유는 무엇인가요?

A. 정규화를 진행할 수록 하나의 테이블을 여러 테이블로 나누게 되는데, 만약 데이터 호출 시 여러 테이블을 불러서 JOIN을 해줘야한다면 이 비용도 만만치 않기 때문에 역정규화를 한다.

 

* DB 정규화 개념 설명 및 예제가 가장 잘 나와있다고 생각되는 사이트

https://wkdtjsgur100.github.io/database-normalization/

# 관계형 데이터베이스와 비 관계형 데이터베이스
Q. 관계형 데이터베이스와 비 관계형 데이터베이스 차이점에 대해 설명해보세요.

A. 관계형 데이터베이스란 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다.이처럼 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스의 특징이다.

비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 
요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히들 NoSQL(not only SQL)이라고 하며 데이터를 저장할 때 SQL문이 아닌 다른 프로그래밍 언어 및 구문을 사용한다.

Q. RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요.

A. 가장 큰 장점이라면 JOIN 처리가 없기 때문에 스케일 아웃을 통한 노드 확장 용이하다는 점이다.
 뿐만아니라 가변적인 데이터구조로 데이터를 저장할 수 있어서 훨씬 더 유연성이 높다. 단점으로는 다양하고 복잡한 쿼리가 불가능하고 일관성을 항상 보장할 수 없는 것을 꼽을 수 있다.

속도적인 측면에서는 대표적인 RDBMS인 MySQL이나 ORACLE이 워낙 최적화가 잘 되어있기도하고 주어진 상황에 따라 아주 케이스바이케이스라 뭐가 더 좋다라고는 하기 어렵다.

Q. NoSQL이란?

A.

NoSQL 데이터베이스는 관계형 데이터베이스(RDB)보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다.

단순 검색 및 추가 작업을 위한 매우 최적화된 키-값 저장 공간을 사용한다.

빅데이터 시대에 따라 많은 양의 데이터를 효율적으로 처리하기 위해 등장하였다. (분산처리, 빠른쓰기 및 데이터의 안정성)

분산형 구조를 통해 여러 대의 서버에 분산해 저장하고, 분산시에는 데이터를 상호 복제에 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조를 갖고 있다.

Q. 어떤상황에서 NoSQL을 쓰는 것이 더 적합한가?

A. 비정형 데이터를 저장해야할 때 가장 적합하다. 검색기능이 있을 때도 좋다고들하는데 의견이 분분하다. 케바케라는 말이 적절할 것 같다.

